
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>A Brief Tour of Symbolic PyMC &#8212; Symbolic PyMC  documentation</title>
    <link rel="stylesheet" href="_static/semantic-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" />
    <link rel="stylesheet" type="text/css" href="_static/default.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <script type="text/javascript" src="_static/highlight.min.js"></script>
    <script type="text/javascript" src="_static/semantic.min.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Welcome to Symbolic PyMC’s documentation!" href="index.html" />
<script>hljs.initHighlightingOnLoad();</script>
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">



  </head><body>
<div class="ui vertical center aligned">

    <div class="ui container">
        <div class="ui large secondary pointing menu">
            <a class="item" href="/">
                <img class="ui bottom aligned tiny image" src="https://cdn.rawgit.com/pymc-devs/pymc3/master/docs/logos/svg/PyMC3_banner.svg" />
            </a>
            
            <div class="right menu">
                <div class="item">
                    <form class="ui icon input" action="search.html" method="get">
                        <input type="text" placeholder="Search..." name="q" />
                        <i class="search link icon"></i>
                    </form>
                </div>
                <a class="item" href="https://github.com/pymc-devs/symbolic-pymc"><i class="github blue icon large"></i></a>
            </div>
        </div>
    </div>
    
</div>

<div class="ui container" role="main">
    

    <div class="ui vertical segment">
        
  <div class="section" id="a-brief-tour-of-symbolic-pymc">
<h1>A Brief Tour of Symbolic PyMC<a class="headerlink" href="#a-brief-tour-of-symbolic-pymc" title="Permalink to this headline">¶</a></h1>
<blockquote>
<div><dl class="field-list simple">
<dt class="field-odd">Author</dt>
<dd class="field-odd"><p>Brandon T. Willard</p>
</dd>
<dt class="field-even">Date</dt>
<dd class="field-even"><p>2019-08-03</p>
</dd>
</dl>
</div></blockquote>
<div class="section" id="introduction">
<h2>1 Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>In this document we’ll cover the basics of the Symbolic PymC package while
implementing a symbolic “search-and-replace” for terms
like <code class="docutils literal notranslate"><span class="pre">tf.matmul(A,</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">y)</span></code>
into <code class="docutils literal notranslate"><span class="pre">tf.matmul(A,</span> <span class="pre">x)</span> <span class="pre">+</span> <span class="pre">tf.matmul(A,</span> <span class="pre">y)</span></code>.  In other words, we will
demonstrate how to implement the distributive property of matrix multiplication
so that it can be applied to arbitrary TensorFlow graphs.</p>
<p>Symbolic PyMC allows one to implement rewrite rules like the distributive
property, as well as other sophisticated symbolic manipulations of graphs,
through a combination of fundamental computational concepts with direct and
transparent implementations in pure Python.</p>
<p>Throughout the course of our implementation, we will briefly introduce these concepts
and explicitly show how they relate to graph manipulations and the high-level math
that they model.</p>
<p>We start by creating a graph of our target
expressions–i.e. <code class="docutils literal notranslate"><span class="pre">tf.matmul(A,</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></code>–in TensorFlow.  We do this so
that we can inspect its structure and determine exactly what we need to search
for and replace.</p>
<div class="highlight-python notranslate" id="tf-matmul-graph"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="kn">import</span> <span class="nn">tensorflow</span> <span class="kn">as</span> <span class="nn">tf</span>

<span class="kn">from</span> <span class="nn">IPython.lib.pretty</span> <span class="kn">import</span> <span class="n">pprint</span>

<span class="kn">from</span> <span class="nn">tensorflow.python.eager.context</span> <span class="kn">import</span> <span class="n">graph_mode</span>


<span class="k">with</span> <span class="n">graph_mode</span><span class="p">():</span>
    <span class="c1"># Matrix</span>
    <span class="n">A_tf</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">compat</span><span class="o">.</span><span class="n">v1</span><span class="o">.</span><span class="n">placeholder</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;A&#39;</span><span class="p">,</span>
                                    <span class="n">shape</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">TensorShape</span><span class="p">([</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">]))</span>
    <span class="c1"># Column vectors</span>
    <span class="n">x_tf</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">compat</span><span class="o">.</span><span class="n">v1</span><span class="o">.</span><span class="n">placeholder</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span>
                                    <span class="n">shape</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">TensorShape</span><span class="p">([</span><span class="bp">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
    <span class="n">y_tf</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">compat</span><span class="o">.</span><span class="n">v1</span><span class="o">.</span><span class="n">placeholder</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">,</span>
                                    <span class="n">shape</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">TensorShape</span><span class="p">([</span><span class="bp">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
    <span class="c1"># The multiplication</span>
    <span class="n">z_tf</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">A_tf</span><span class="p">,</span> <span class="n">x_tf</span> <span class="o">+</span> <span class="n">y_tf</span><span class="p">)</span>
</pre></div>
</div>
<p>A text print-out of the full TensorFlow graph is provided by the debug print
function <code class="docutils literal notranslate"><span class="pre">tf_dprint</span></code>.</p>
<div class="highlight-python notranslate" id="tf-print-graph"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">symbolic_pymc.tensorflow.printing</span> <span class="kn">import</span> <span class="n">tf_dprint</span>

<span class="n">tf_dprint</span><span class="p">(</span><span class="n">z_tf</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Tensor</span><span class="p">(</span><span class="n">MatMul</span><span class="p">):</span><span class="mi">0</span><span class="p">,</span>   <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="s2">&quot;MatMul_5:0&quot;</span>
<span class="o">|</span>  <span class="n">Op</span><span class="p">(</span><span class="n">MatMul</span><span class="p">)</span>       <span class="s2">&quot;MatMul_5&quot;</span>
<span class="o">|</span>  <span class="o">|</span>  <span class="n">Tensor</span><span class="p">(</span><span class="n">Placeholder</span><span class="p">):</span><span class="mi">0</span><span class="p">,</span>        <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>      <span class="s2">&quot;A_1:0&quot;</span>
<span class="o">|</span>  <span class="o">|</span>  <span class="n">Tensor</span><span class="p">(</span><span class="n">Add</span><span class="p">):</span><span class="mi">0</span><span class="p">,</span>        <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="s2">&quot;add_3:0&quot;</span>
<span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>  <span class="n">Op</span><span class="p">(</span><span class="n">Add</span><span class="p">)</span>    <span class="s2">&quot;add_3&quot;</span>
<span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>  <span class="n">Tensor</span><span class="p">(</span><span class="n">Placeholder</span><span class="p">):</span><span class="mi">0</span><span class="p">,</span>  <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="s2">&quot;x_1:0&quot;</span>
<span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>  <span class="n">Tensor</span><span class="p">(</span><span class="n">Placeholder</span><span class="p">):</span><span class="mi">0</span><span class="p">,</span>  <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="s2">&quot;y_1:0&quot;</span>
</pre></div>
</div>
<p>The output of Listing <a class="reference internal" href="#tf-print-graph">tf-print-graph</a> shows us the underlying operators (e.g. <code class="docutils literal notranslate"><span class="pre">MatMul</span></code>,
<code class="docutils literal notranslate"><span class="pre">Placeholder</span></code>, <code class="docutils literal notranslate"><span class="pre">Add</span></code>) and their arguments.</p>
<p>To “match/search for” combinations of TensorFlow operations–or, in other words, graphs–like
<a class="reference internal" href="#tf-print-graph">tf-print-graph</a>, we use <a class="reference external" href="https://en.wikipedia.org/wiki/Unification_(computer_science)">**unification**</a>; to “replace” parts of a graph (well, to produce copies with
replaced parts), we use <a class="reference external" href="https://en.wikipedia.org/wiki/Reification_(computer_science)">**reification**</a>.  Symbolic PyMC provides support for
these using <a class="reference external" href="https://www.tensorflow.org/">TensorFlow</a> (and <a class="reference external" href="http://deeplearning.net/software/theano/">Theano</a>) graphs via <strong>meta objects</strong> and <strong>expression-tuples</strong>.</p>
</div>
<div class="section" id="meta-objects">
<h2>2 Meta Objects<a class="headerlink" href="#meta-objects" title="Permalink to this headline">¶</a></h2>
<p>Meta objects model the essential components of TensorFlow graphs, while allowing one
to use input that isn’t normally valid.  More specifically, we can
construct meta graphs that contain <strong>logic variables</strong>.  Later, those logic
variables can be replaced with other objects that allow the meta graph to
be converted into a real TensorFlow graph.</p>
<p>Existing TensorFlow graphs can be converted to their meta graph equivalents with
the <code class="docutils literal notranslate"><span class="pre">mt</span></code> helper object.</p>
<div class="highlight-python notranslate" id="convert-to-meta"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">symbolic_pymc.tensorflow.meta</span> <span class="kn">import</span> <span class="n">mt</span>


<span class="n">z_mt</span> <span class="o">=</span> <span class="n">mt</span><span class="p">(</span><span class="n">z_tf</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate" id="convert-to-meta-print"><div class="highlight"><pre><span></span><span class="n">tf_dprint</span><span class="p">(</span><span class="n">z_mt</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Tensor</span><span class="p">(</span><span class="n">MatMul</span><span class="p">):</span><span class="mi">0</span><span class="p">,</span>   <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="s2">&quot;MatMul_5:0&quot;</span>
<span class="o">|</span>  <span class="n">Op</span><span class="p">(</span><span class="n">MatMul</span><span class="p">)</span>       <span class="s2">&quot;MatMul_5&quot;</span>
<span class="o">|</span>  <span class="o">|</span>  <span class="n">Tensor</span><span class="p">(</span><span class="n">Placeholder</span><span class="p">):</span><span class="mi">0</span><span class="p">,</span>        <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>      <span class="s2">&quot;A_1:0&quot;</span>
<span class="o">|</span>  <span class="o">|</span>  <span class="n">Tensor</span><span class="p">(</span><span class="n">Add</span><span class="p">):</span><span class="mi">0</span><span class="p">,</span>        <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="s2">&quot;add_3:0&quot;</span>
<span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>  <span class="n">Op</span><span class="p">(</span><span class="n">Add</span><span class="p">)</span>    <span class="s2">&quot;add_3&quot;</span>
<span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>  <span class="n">Tensor</span><span class="p">(</span><span class="n">Placeholder</span><span class="p">):</span><span class="mi">0</span><span class="p">,</span>  <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="s2">&quot;x_1:0&quot;</span>
<span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>  <span class="n">Tensor</span><span class="p">(</span><span class="n">Placeholder</span><span class="p">):</span><span class="mi">0</span><span class="p">,</span>  <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="s2">&quot;y_1:0&quot;</span>
</pre></div>
</div>
<p>A meta graph can be converted to a TensorFlow graph using its <code class="docutils literal notranslate"><span class="pre">reify</span></code> method.</p>
<div class="highlight-python notranslate" id="meta-to-tf"><div class="highlight"><pre><span></span><span class="n">tf_dprint</span><span class="p">(</span><span class="n">z_mt</span><span class="o">.</span><span class="n">reify</span><span class="p">())</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Tensor</span><span class="p">(</span><span class="n">MatMul</span><span class="p">):</span><span class="mi">0</span><span class="p">,</span>   <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="s2">&quot;MatMul:0&quot;</span>
<span class="o">|</span>  <span class="n">Op</span><span class="p">(</span><span class="n">MatMul</span><span class="p">)</span>       <span class="s2">&quot;MatMul&quot;</span>
<span class="o">|</span>  <span class="o">|</span>  <span class="n">Tensor</span><span class="p">(</span><span class="n">Placeholder</span><span class="p">):</span><span class="mi">0</span><span class="p">,</span>        <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>      <span class="s2">&quot;A:0&quot;</span>
<span class="o">|</span>  <span class="o">|</span>  <span class="n">Tensor</span><span class="p">(</span><span class="n">Add</span><span class="p">):</span><span class="mi">0</span><span class="p">,</span>        <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="s2">&quot;add:0&quot;</span>
<span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>  <span class="n">Op</span><span class="p">(</span><span class="n">Add</span><span class="p">)</span>    <span class="s2">&quot;add&quot;</span>
<span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>  <span class="n">Tensor</span><span class="p">(</span><span class="n">Placeholder</span><span class="p">):</span><span class="mi">0</span><span class="p">,</span>  <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="s2">&quot;x:0&quot;</span>
<span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>  <span class="n">Tensor</span><span class="p">(</span><span class="n">Placeholder</span><span class="p">):</span><span class="mi">0</span><span class="p">,</span>  <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="s2">&quot;y:0&quot;</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">mt</span></code> object also makes it easier to construct meta graphs by hand.</p>
<div class="highlight-python notranslate" id="create-meta-graph"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">unification</span> <span class="kn">import</span> <span class="n">unify</span><span class="p">,</span> <span class="n">reify</span><span class="p">,</span> <span class="n">var</span>


<span class="k">with</span> <span class="n">graph_mode</span><span class="p">():</span>
    <span class="n">add_mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">var</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pprint</span><span class="p">(</span><span class="n">add_mt</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">TFlowMetaTensor</span><span class="p">(</span>
  <span class="n">dtype</span><span class="o">=~</span><span class="n">_5</span><span class="p">,</span>
  <span class="n">op</span><span class="o">=</span><span class="n">TFlowMetaOp</span><span class="p">(</span>
    <span class="n">op_def</span><span class="o">=</span><span class="n">TFlowMetaOpDef</span><span class="p">(</span><span class="n">Add</span><span class="p">),</span>
    <span class="n">node_def</span><span class="o">=</span><span class="n">TFlowMetaNodeDef</span><span class="p">(</span> <span class="n">op</span><span class="o">=</span><span class="s1">&#39;Add&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;add&#39;</span><span class="p">,</span> <span class="n">attr</span><span class="o">=</span><span class="n">OrderedDict</span><span class="p">()),</span>
    <span class="n">inputs</span><span class="o">=</span><span class="p">(</span><span class="n">TFlowMetaConstant</span><span class="p">(</span> <span class="p">),</span> <span class="o">~</span><span class="n">a</span><span class="p">),</span>
    <span class="n">name</span><span class="o">=</span><span class="s1">&#39;add&#39;</span><span class="p">),</span>
  <span class="n">value_index</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
  <span class="n">shape</span><span class="o">=~</span><span class="n">_6</span><span class="p">,</span>
  <span class="n">name</span><span class="o">=</span><span class="s1">&#39;add:0&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>In <a class="reference internal" href="#create-meta-graph">create-meta-graph</a>, we created a graph of <code class="docutils literal notranslate"><span class="pre">1</span></code> plus
a <code class="docutils literal notranslate"><span class="pre">unification</span></code> logic variable with the name <code class="docutils literal notranslate"><span class="pre">'a'</span></code>. This
wouldn’t be possible with a standard TensorFlow graph.</p>
<p>Also, because one of the elements in the graph is a logic variable, it cannot be
converted into a TensorFlow graph. Instead, if we attempt to use the meta
graph’s <code class="docutils literal notranslate"><span class="pre">reify</span></code> method, we are simply given the meta graph back.</p>
<div class="highlight-python notranslate" id="bad-reify-meta-graphh"><div class="highlight"><pre><span></span><span class="n">pprint</span><span class="p">(</span><span class="n">add_mt</span><span class="o">.</span><span class="n">reify</span><span class="p">())</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">TFlowMetaTensor</span><span class="p">(</span>
  <span class="n">dtype</span><span class="o">=~</span><span class="n">_5</span><span class="p">,</span>
  <span class="n">op</span><span class="o">=</span><span class="n">TFlowMetaOp</span><span class="p">(</span>
    <span class="n">op_def</span><span class="o">=</span><span class="n">TFlowMetaOpDef</span><span class="p">(</span><span class="n">Add</span><span class="p">),</span>
    <span class="n">node_def</span><span class="o">=</span><span class="n">TFlowMetaNodeDef</span><span class="p">(</span> <span class="n">op</span><span class="o">=</span><span class="s1">&#39;Add&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;add&#39;</span><span class="p">,</span> <span class="n">attr</span><span class="o">=</span><span class="n">OrderedDict</span><span class="p">()),</span>
    <span class="n">inputs</span><span class="o">=</span><span class="p">(</span><span class="n">TFlowMetaConstant</span><span class="p">(</span> <span class="p">),</span> <span class="o">~</span><span class="n">a</span><span class="p">),</span>
    <span class="n">name</span><span class="o">=</span><span class="s1">&#39;add&#39;</span><span class="p">),</span>
  <span class="n">value_index</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
  <span class="n">shape</span><span class="o">=~</span><span class="n">_6</span><span class="p">,</span>
  <span class="n">name</span><span class="o">=</span><span class="s1">&#39;add:0&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="s-expressions">
<h2>3 S-expressions<a class="headerlink" href="#s-expressions" title="Permalink to this headline">¶</a></h2>
<p>As an alternative approach to full meta graph conversion, we can also convert
TensorFlow graphs into an <a class="reference external" href="https://en.wikipedia.org/wiki/S-expression">S-expression-like</a> form.</p>
<div class="highlight-python notranslate" id="etuplize-graph"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">symbolic_pymc.etuple</span> <span class="kn">import</span> <span class="n">etuple</span><span class="p">,</span> <span class="n">etuplize</span>


<span class="n">z_sexp</span> <span class="o">=</span> <span class="n">etuplize</span><span class="p">(</span><span class="n">z_tf</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate" id="etuplize-graph-print"><div class="highlight"><pre><span></span><span class="n">pprint</span><span class="p">(</span><span class="n">z_sexp</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ExpressionTuple</span><span class="p">((</span>
  <span class="n">TFlowMetaOpDef</span><span class="p">(</span><span class="n">MatMul</span><span class="p">),</span>
  <span class="n">ExpressionTuple</span><span class="p">((</span>
    <span class="n">TFlowMetaOpDef</span><span class="p">(</span><span class="n">Placeholder</span><span class="p">),</span>
    <span class="s1">&#39;float64&#39;</span><span class="p">,</span>
    <span class="n">ExpressionTuple</span><span class="p">((</span>
      <span class="n">symbolic_pymc</span><span class="o">.</span><span class="n">tensorflow</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">TFlowMetaTensorShape</span><span class="p">,</span>
      <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">))),</span>
    <span class="s1">&#39;A_1&#39;</span><span class="p">)),</span>
  <span class="n">ExpressionTuple</span><span class="p">((</span>
    <span class="n">TFlowMetaOpDef</span><span class="p">(</span><span class="n">Add</span><span class="p">),</span>
    <span class="n">ExpressionTuple</span><span class="p">((</span>
      <span class="n">TFlowMetaOpDef</span><span class="p">(</span><span class="n">Placeholder</span><span class="p">),</span>
      <span class="s1">&#39;float64&#39;</span><span class="p">,</span>
      <span class="n">ExpressionTuple</span><span class="p">((</span>
        <span class="n">symbolic_pymc</span><span class="o">.</span><span class="n">tensorflow</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">TFlowMetaTensorShape</span><span class="p">,</span>
        <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">))),</span>
      <span class="s1">&#39;x_1&#39;</span><span class="p">)),</span>
    <span class="n">ExpressionTuple</span><span class="p">((</span>
      <span class="n">TFlowMetaOpDef</span><span class="p">(</span><span class="n">Placeholder</span><span class="p">),</span>
      <span class="s1">&#39;float64&#39;</span><span class="p">,</span>
      <span class="n">ExpressionTuple</span><span class="p">((</span>
        <span class="n">symbolic_pymc</span><span class="o">.</span><span class="n">tensorflow</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">TFlowMetaTensorShape</span><span class="p">,</span>
        <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">))),</span>
      <span class="s1">&#39;y_1&#39;</span><span class="p">)),</span>
    <span class="s1">&#39;add_3&#39;</span><span class="p">)),</span>
  <span class="bp">False</span><span class="p">,</span>
  <span class="bp">False</span><span class="p">,</span>
  <span class="s1">&#39;MatMul_5&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>By working with <code class="docutils literal notranslate"><span class="pre">etuple``s,</span> <span class="pre">we</span> <span class="pre">can</span> <span class="pre">use</span> <span class="pre">arbitrary</span> <span class="pre">Python</span> <span class="pre">functions</span> <span class="pre">in</span>
<span class="pre">conjunction</span> <span class="pre">with</span> <span class="pre">meta</span> <span class="pre">graphs</span> <span class="pre">and</span> <span class="pre">logic</span> <span class="pre">variables.</span> <span class="pre">Basically,</span>
<span class="pre">an</span> <span class="pre">``etuple</span></code> can be manipulated until all of its
constituent logic variables and meta objects are eventually able to be converted
into concrete base objects, then the <code class="docutils literal notranslate"><span class="pre">etuple</span></code> can be evaluated.</p>
<p>For example, in Listing <a class="reference internal" href="#etuple-eval-example">etuple-eval-example</a>, we create an <code class="docutils literal notranslate"><span class="pre">etuple</span></code>
that uses the TensorFlow function <code class="docutils literal notranslate"><span class="pre">tf.add</span></code> with a logic variable argument.</p>
<div class="highlight-python notranslate" id="etuple-eval-example"><div class="highlight"><pre><span></span><span class="n">x_lv</span><span class="p">,</span> <span class="n">y_lv</span> <span class="o">=</span> <span class="n">var</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">),</span> <span class="n">var</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>

<span class="n">add_tf_pat</span> <span class="o">=</span> <span class="n">etuple</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">add</span><span class="p">,</span> <span class="n">x_lv</span><span class="p">,</span> <span class="n">y_lv</span><span class="p">)</span>
</pre></div>
</div>
<p>Normally, this wouldn’t be possible, as demonstrated in Listing <a class="reference internal" href="#etuple-bad-usage-example">etuple-bad-usage-example</a>.</p>
<div class="highlight-python notranslate" id="etuple-bad-usage-example"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">tf</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x_lv</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>Attempt to convert a value (~x) with an unsupported type (&lt;class &#39;unification.variable.Var&#39;&gt;) to a Tensor.
</pre></div>
</div>
<p>We would get the same error if we attempted to evaluate the <code class="docutils literal notranslate"><span class="pre">etuple</span></code>,
which is done by accessing the <code class="docutils literal notranslate"><span class="pre">eval_obj</span></code> property.  However, after
performing a simple manipulation that replaces the logic variable with valid
input to <code class="docutils literal notranslate"><span class="pre">tf.add</span></code>, we are able to evaluate the <code class="docutils literal notranslate"><span class="pre">etuple</span></code>, as
demonstrated in Listings <a class="reference internal" href="#etuple-reify-example">etuple-reify-example</a> and
<a class="reference internal" href="#etuple-reify-eval-print-example">etuple-reify-eval-print-example</a>.</p>
<div class="highlight-python notranslate" id="etuple-reify-example"><div class="highlight"><pre><span></span><span class="n">add_pat_new</span> <span class="o">=</span> <span class="n">reify</span><span class="p">(</span><span class="n">add_tf_pat</span><span class="p">,</span> <span class="p">{</span><span class="n">x_lv</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y_lv</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span>
</pre></div>
</div>
<div class="highlight-python notranslate" id="etuple-reify-print-example"><div class="highlight"><pre><span></span><span class="n">pprint</span><span class="p">(</span><span class="n">add_pat_new</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ExpressionTuple</span><span class="p">((</span>
  <span class="o">&lt;</span><span class="n">function</span> <span class="n">tensorflow</span><span class="o">.</span><span class="n">python</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">gen_math_ops</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="mi">1</span><span class="p">,</span>
  <span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-python notranslate" id="etuple-reify-eval-print-example"><div class="highlight"><pre><span></span><span class="n">pprint</span><span class="p">(</span><span class="n">add_pat_new</span><span class="o">.</span><span class="n">eval_obj</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span> <span class="nb">id</span><span class="o">=</span><span class="mi">34</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">int32</span><span class="p">,</span> <span class="n">numpy</span><span class="o">=</span><span class="mi">2</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Working with S-expressions is much like manipulating a subset of Python AST, so
that–in effect–one can automate the production of TensorFlow-using code.</p>
</div>
<div class="section" id="unification-and-reification">
<h2>4 Unification and Reification<a class="headerlink" href="#unification-and-reification" title="Permalink to this headline">¶</a></h2>
<p>With the ability to use logic variables and TensorFlow graphs together, we can
“search” arbitrary graphs using <strong>unification</strong> and produce new graphs by replacing
logic variables with previously unified results–via <strong>reification</strong>.</p>
<p>We start by making “patterns” or templates for the subgraphs we would like to match.
Patterns, in this case, take the form of meta graphs or S-expr graphs with the
desired structure and logic variables in place of “unknown” or arbitrary terms
that we might like to reference elsewhere.</p>
<p>Listing <a class="reference internal" href="#matmul-pattern">matmul-pattern</a> represents an S-expr that evaluates to a graph in
which two terms are matrix-multiplied.</p>
<div class="highlight-python notranslate" id="matmul-pattern"><div class="highlight"><pre><span></span><span class="n">A_lv</span><span class="p">,</span> <span class="n">B_lv</span> <span class="o">=</span> <span class="n">var</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">),</span> <span class="n">var</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>

<span class="n">matmul_pat</span> <span class="o">=</span> <span class="n">etuple</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">matmul</span><span class="p">,</span> <span class="n">A_lv</span><span class="p">,</span> <span class="n">B_lv</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="n">var</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>The first two terms are logic variables, so they can be matched/unified with anything.</p>
<p>The remaining two booleans and name parameter are the optional arguments
to <code class="docutils literal notranslate"><span class="pre">mt.matmul</span></code>, and they correspond to
the <code class="docutils literal notranslate"><span class="pre">transpose_a</span></code>, <code class="docutils literal notranslate"><span class="pre">transpose_b</span></code>, and name parameters of the
original <code class="docutils literal notranslate"><span class="pre">tf.matmul</span></code> operator (i.e. the operator modeled by the meta
operator <code class="docutils literal notranslate"><span class="pre">mt.matmul</span></code>).  By setting the first two optional parameters
to non-logic variable values, we are effectively restricting the possible
matches.</p>
<p>“Matching” a graph against our pattern is accomplished with <strong>unification</strong>.
Unification of two graphs implies unification of all sub-graphs and elements
between them.  When unification is successful, it returns a map of logic
variables and their unified values.  If there are no logic variables in the
graphs–it simply returns an empty map.  If unification fails, it
returns <code class="docutils literal notranslate"><span class="pre">False</span></code>–at least in the implementation we use, but not
necessarily in general.</p>
<div class="section" id="id1">
<h3>4.1 Unification<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>We can perform the unification using the function <code class="docutils literal notranslate"><span class="pre">unify</span></code>.  The result
is a <code class="docutils literal notranslate"><span class="pre">dict</span></code> mapping logic variables to their unified values.</p>
<div class="highlight-python notranslate" id="matmul-pattern-unify"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="n">unify</span><span class="p">(</span><span class="n">matmul_pat</span><span class="p">,</span> <span class="n">z_sexp</span><span class="p">,</span> <span class="p">{})</span>
</pre></div>
</div>
<div class="highlight-python notranslate" id="matmul-pattern-unify-print"><div class="highlight"><pre><span></span><span class="n">pprint</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="o">~</span><span class="n">A</span><span class="p">:</span> <span class="n">ExpressionTuple</span><span class="p">((</span>
   <span class="n">TFlowMetaOpDef</span><span class="p">(</span><span class="n">Placeholder</span><span class="p">),</span>
   <span class="s1">&#39;float64&#39;</span><span class="p">,</span>
   <span class="n">ExpressionTuple</span><span class="p">((</span>
     <span class="n">symbolic_pymc</span><span class="o">.</span><span class="n">tensorflow</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">TFlowMetaTensorShape</span><span class="p">,</span>
     <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">))),</span>
   <span class="s1">&#39;A&#39;</span><span class="p">)),</span>
 <span class="o">~</span><span class="n">B</span><span class="p">:</span> <span class="n">ExpressionTuple</span><span class="p">((</span>
   <span class="n">TFlowMetaOpDef</span><span class="p">(</span><span class="n">Add</span><span class="p">),</span>
   <span class="n">ExpressionTuple</span><span class="p">((</span>
     <span class="n">TFlowMetaOpDef</span><span class="p">(</span><span class="n">Placeholder</span><span class="p">),</span>
     <span class="s1">&#39;float64&#39;</span><span class="p">,</span>
     <span class="n">ExpressionTuple</span><span class="p">((</span>
       <span class="n">symbolic_pymc</span><span class="o">.</span><span class="n">tensorflow</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">TFlowMetaTensorShape</span><span class="p">,</span>
       <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">))),</span>
     <span class="s1">&#39;x&#39;</span><span class="p">)),</span>
   <span class="n">ExpressionTuple</span><span class="p">((</span>
     <span class="n">TFlowMetaOpDef</span><span class="p">(</span><span class="n">Placeholder</span><span class="p">),</span>
     <span class="s1">&#39;float64&#39;</span><span class="p">,</span>
     <span class="n">ExpressionTuple</span><span class="p">((</span>
       <span class="n">symbolic_pymc</span><span class="o">.</span><span class="n">tensorflow</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">TFlowMetaTensorShape</span><span class="p">,</span>
       <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">))),</span>
     <span class="s1">&#39;y&#39;</span><span class="p">)),</span>
   <span class="s1">&#39;add&#39;</span><span class="p">)),</span>
 <span class="o">~</span><span class="n">name</span><span class="p">:</span> <span class="s1">&#39;MatMul&#39;</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h3>4.2 Reification<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>Using <code class="docutils literal notranslate"><span class="pre">reify</span></code>, we can “fill-in”–or replace–the logic variables of
our “pattern” with the matches obtained by <code class="docutils literal notranslate"><span class="pre">unify</span></code> that are held
within the variable <code class="docutils literal notranslate"><span class="pre">s</span></code>, or we could specify our own substitutions
based on that information.</p>
<p>In Listing <a class="reference internal" href="#matmul-pattern-reify">matmul-pattern-reify</a>, we simply change the <code class="docutils literal notranslate"><span class="pre">'name'</span></code> value in the
and create a new graph with that value.  The end result is a version of the original
graph, <code class="docutils literal notranslate"><span class="pre">z_sexp</span></code>, with a new name.</p>
<div class="highlight-python notranslate" id="matmul-pattern-reify"><div class="highlight"><pre><span></span><span class="n">s</span><span class="p">[</span><span class="n">var</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">)]</span> <span class="o">=</span> <span class="s1">&#39;a new name&#39;</span>

<span class="n">z_sexp_re</span> <span class="o">=</span> <span class="n">reify</span><span class="p">(</span><span class="n">matmul_pat</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate" id="matmul-pattern-reify-print"><div class="highlight"><pre><span></span><span class="n">pprint</span><span class="p">(</span><span class="n">z_sexp_re</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ExpressionTuple</span><span class="p">((</span>
  <span class="n">TFlowMetaOpDef</span><span class="p">(</span><span class="n">MatMul</span><span class="p">),</span>
  <span class="n">ExpressionTuple</span><span class="p">((</span>
    <span class="n">TFlowMetaOpDef</span><span class="p">(</span><span class="n">Placeholder</span><span class="p">),</span>
    <span class="s1">&#39;float64&#39;</span><span class="p">,</span>
    <span class="n">ExpressionTuple</span><span class="p">((</span>
      <span class="n">symbolic_pymc</span><span class="o">.</span><span class="n">tensorflow</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">TFlowMetaTensorShape</span><span class="p">,</span>
      <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">))),</span>
    <span class="s1">&#39;A&#39;</span><span class="p">)),</span>
  <span class="n">ExpressionTuple</span><span class="p">((</span>
    <span class="n">TFlowMetaOpDef</span><span class="p">(</span><span class="n">Add</span><span class="p">),</span>
    <span class="n">ExpressionTuple</span><span class="p">((</span>
      <span class="n">TFlowMetaOpDef</span><span class="p">(</span><span class="n">Placeholder</span><span class="p">),</span>
      <span class="s1">&#39;float64&#39;</span><span class="p">,</span>
      <span class="n">ExpressionTuple</span><span class="p">((</span>
        <span class="n">symbolic_pymc</span><span class="o">.</span><span class="n">tensorflow</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">TFlowMetaTensorShape</span><span class="p">,</span>
        <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">))),</span>
      <span class="s1">&#39;x&#39;</span><span class="p">)),</span>
    <span class="n">ExpressionTuple</span><span class="p">((</span>
      <span class="n">TFlowMetaOpDef</span><span class="p">(</span><span class="n">Placeholder</span><span class="p">),</span>
      <span class="s1">&#39;float64&#39;</span><span class="p">,</span>
      <span class="n">ExpressionTuple</span><span class="p">((</span>
        <span class="n">symbolic_pymc</span><span class="o">.</span><span class="n">tensorflow</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">TFlowMetaTensorShape</span><span class="p">,</span>
        <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">))),</span>
      <span class="s1">&#39;y&#39;</span><span class="p">)),</span>
    <span class="s1">&#39;add&#39;</span><span class="p">)),</span>
  <span class="bp">False</span><span class="p">,</span>
  <span class="bp">False</span><span class="p">,</span>
  <span class="s1">&#39;a new name&#39;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="finishing-our-implementation">
<h3>4.3 Finishing our Implementation<a class="headerlink" href="#finishing-our-implementation" title="Permalink to this headline">¶</a></h3>
<p>We can also reify an entirely different graph using the values extracted
from the graph <code class="docutils literal notranslate"><span class="pre">z_sexp</span></code>.  In this case, we create an “output” pattern graph, to
complement our “input” pattern graph, <code class="docutils literal notranslate"><span class="pre">matmul_pat</span></code>.</p>
<p>If we combine our matrix multiplication and addition <code class="docutils literal notranslate"><span class="pre">etuple</span></code> patterns, we
can extract all the arguments needed as input to a distributed multiplication pattern.</p>
<div class="highlight-python notranslate" id="dist-new-pattern"><div class="highlight"><pre><span></span><span class="n">output_pat</span> <span class="o">=</span> <span class="n">etuple</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">add</span><span class="p">,</span>
                    <span class="n">etuple</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">matmul</span><span class="p">,</span> <span class="n">A_lv</span><span class="p">,</span> <span class="n">x_lv</span><span class="p">),</span>
                    <span class="n">etuple</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">matmul</span><span class="p">,</span> <span class="n">A_lv</span><span class="p">,</span> <span class="n">y_lv</span><span class="p">))</span>
</pre></div>
</div>
<p>With the correct assignments/mappings of the constituent logic variables, <code class="docutils literal notranslate"><span class="pre">A_lv</span></code>,
<code class="docutils literal notranslate"><span class="pre">x_lv</span></code> and <code class="docutils literal notranslate"><span class="pre">y_lv</span></code>, we can reify <code class="docutils literal notranslate"><span class="pre">output_pat</span></code> and obtain
the desired graph.  From our earlier unification results in Listing <a class="reference internal" href="#matmul-pattern-unify">matmul-pattern-unify</a>,
we only need to apply the addition pattern (i.e. virtually the same
as <code class="docutils literal notranslate"><span class="pre">add_tf_pat</span></code>, just with <code class="docutils literal notranslate"><span class="pre">mt.add</span></code> instead
of <code class="docutils literal notranslate"><span class="pre">tf.add</span></code>) to the unified valued of the second multiplication
pattern argument, <code class="docutils literal notranslate"><span class="pre">B_lv</span></code>.</p>
<div class="highlight-python notranslate" id="dist-add-unify"><div class="highlight"><pre><span></span><span class="n">add_pat</span> <span class="o">=</span> <span class="n">etuple</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">add</span><span class="p">,</span> <span class="n">x_lv</span><span class="p">,</span> <span class="n">y_lv</span><span class="p">,</span> <span class="n">var</span><span class="p">())</span>

<span class="n">s_add</span> <span class="o">=</span> <span class="n">unify</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">B_lv</span><span class="p">],</span> <span class="n">add_pat</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
<p>In Listing <a class="reference internal" href="#dist-add-unify">dist-add-unify</a>, we added an extra element to <code class="docutils literal notranslate"><span class="pre">add_pat</span></code> for
the name parameter, since–upon inspection–we can see that the sub-graph for
addition, <code class="docutils literal notranslate"><span class="pre">s[B_lv]</span></code>, actually has four elements: the meta
operator <code class="docutils literal notranslate"><span class="pre">mt.add</span></code>, two sub-sub-graphs that construct the addends
denoted by <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code>, and the output/operator name used by TensorFlow.
Without this extra element, the unification would fail, and–although we could’ve
use the exact name in our test/example graph, <code class="docutils literal notranslate"><span class="pre">'add'</span></code>–using an
“anonymous” logic variable like we did is more generally applicable, because it
match <strong>any</strong> name.</p>
<p>Also, notice that we gave our previous unification results/logic variable mappings
to the <code class="docutils literal notranslate"><span class="pre">unify</span></code> function in Listing <a class="reference internal" href="#dist-add-unify">dist-add-unify</a>; we did this in order
to merge all the mappings for the logic variables referenced in our output pattern,
<code class="docutils literal notranslate"><span class="pre">output_pat</span></code>.</p>
<div class="highlight-python notranslate" id="dist-new-pattern-reify"><div class="highlight"><pre><span></span><span class="n">z_new</span> <span class="o">=</span> <span class="n">reify</span><span class="p">(</span><span class="n">output_pat</span><span class="p">,</span> <span class="n">s_add</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate" id="dist-new-pattern-reify-print"><div class="highlight"><pre><span></span><span class="n">tf_dprint</span><span class="p">(</span><span class="n">z_new</span><span class="o">.</span><span class="n">eval_obj</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Tensor</span><span class="p">(</span><span class="n">Add</span><span class="p">):</span><span class="mi">0</span><span class="p">,</span>      <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="s2">&quot;Add_1:0&quot;</span>
<span class="o">|</span>  <span class="n">Op</span><span class="p">(</span><span class="n">Add</span><span class="p">)</span>  <span class="s2">&quot;Add_1&quot;</span>
<span class="o">|</span>  <span class="o">|</span>  <span class="n">Tensor</span><span class="p">(</span><span class="n">MatMul</span><span class="p">):</span><span class="mi">0</span><span class="p">,</span>     <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="s2">&quot;MatMul_1:0&quot;</span>
<span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>  <span class="n">Op</span><span class="p">(</span><span class="n">MatMul</span><span class="p">)</span> <span class="s2">&quot;MatMul_1&quot;</span>
<span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>  <span class="n">Tensor</span><span class="p">(</span><span class="n">Placeholder</span><span class="p">):</span><span class="mi">0</span><span class="p">,</span>  <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>      <span class="s2">&quot;A:0&quot;</span>
<span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>  <span class="n">Tensor</span><span class="p">(</span><span class="n">Placeholder</span><span class="p">):</span><span class="mi">0</span><span class="p">,</span>  <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="s2">&quot;x:0&quot;</span>
<span class="o">|</span>  <span class="o">|</span>  <span class="n">Tensor</span><span class="p">(</span><span class="n">MatMul</span><span class="p">):</span><span class="mi">0</span><span class="p">,</span>     <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="s2">&quot;MatMul_2:0&quot;</span>
<span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>  <span class="n">Op</span><span class="p">(</span><span class="n">MatMul</span><span class="p">)</span> <span class="s2">&quot;MatMul_2&quot;</span>
<span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>  <span class="n">Tensor</span><span class="p">(</span><span class="n">Placeholder</span><span class="p">):</span><span class="mi">0</span><span class="p">,</span>  <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>      <span class="s2">&quot;A:0&quot;</span>
<span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>  <span class="n">Tensor</span><span class="p">(</span><span class="n">Placeholder</span><span class="p">):</span><span class="mi">0</span><span class="p">,</span>  <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="s2">&quot;y:0&quot;</span>
</pre></div>
</div>
<p>As we’ve seen, using only the basics of unification and reification provided by
Symbolic PyMC, one can extract specific elements from TensorFlow graphs and use
them to implement mathematical identities/relations.  Through clever use of
multiple mathematical relations, one can–for example–construct graph
<strong>optimizations</strong> that turn large classes of user-defined statistical models into
computational tractable reformulations.  Similarly, one can construct “normal forms”
for models, making it possible to determine whether or not a user-defined model
is suitable for a specific sampler.</p>
<p>Next, we’ll introduce another major element of Symbolic PyMC that orchestrates
and simplifies sequences of unifications like we used earlier, provides
control-flow-like capabilities, produces fully reified results of arbitrary
form, and does so within a genuinely declarative formalism that carries much of
the same power as logic programming: <a class="reference external" href="http://minikanren.org/">miniKanren</a>!</p>
</div>
</div>
<div class="section" id="relational-programming-in-minikanren">
<h2>5 Relational Programming in miniKanren<a class="headerlink" href="#relational-programming-in-minikanren" title="Permalink to this headline">¶</a></h2>
<p>As mentioned at the end of the last section, Symbolic PyMC uses a Python
implementation of the embedded domain-specific language miniKanren–provided by
the <code class="docutils literal notranslate"><span class="pre">kanren</span></code> package–to orchestrate more sophisticated uses of
unification and reification.  For a quick intro, see <a class="reference external" href="https://github.com/logpy/logpy/blob/master/doc/basic.md">the basic introduction</a>
provided by the <code class="docutils literal notranslate"><span class="pre">kanren</span></code> package.  We’ll cover most of the same
basic material here, but not all.</p>
<p>To start, miniKanren uses <strong>goals</strong> (in the same sense as <a class="reference external" href="https://en.wikipedia.org/wiki/Logic_programming">logic programming</a>) to
assert relations, and the <code class="docutils literal notranslate"><span class="pre">run</span></code> function evaluates those goals and
allows one to specify the exact amount and type of reified output desired from
the <strong>states</strong> that satisfy the goals.</p>
<p>In their most basic form, miniKanren <strong>states</strong> are simply the substitution maps returned by
unification, which–in the normal course of operation–aren’t dealt with directly.</p>
<div class="section" id="the-basic-goals">
<h3>5.1 The Basic Goals<a class="headerlink" href="#the-basic-goals" title="Permalink to this headline">¶</a></h3>
<p>Normally, a user will only need to construct compound goals from a basic set of
primitives.  Arguably, the most primitive goal is the <a class="reference external" href="https://en.wikipedia.org/wiki/Equivalence_relation">equivalence relation</a>
under unification denoted by <code class="docutils literal notranslate"><span class="pre">eq</span></code> in Python.</p>
<p>In Listing , we ask for all successful results/reifications (signified
by the <code class="docutils literal notranslate"><span class="pre">0</span></code> argument) of the logic variable <code class="docutils literal notranslate"><span class="pre">var('q')</span></code> for the goal
<code class="docutils literal notranslate"><span class="pre">eq(var('q'),</span> <span class="pre">1)</span></code>–i.e. unify <code class="docutils literal notranslate"><span class="pre">var('q')</span></code> with <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
<div class="highlight-python notranslate" id="mk-basics-eq"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">kanren</span> <span class="kn">import</span> <span class="n">run</span><span class="p">,</span> <span class="n">eq</span>

<span class="n">q_lv</span> <span class="o">=</span> <span class="n">var</span><span class="p">(</span><span class="s1">&#39;q&#39;</span><span class="p">)</span>
<span class="n">mk_res</span> <span class="o">=</span> <span class="n">run</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">q_lv</span><span class="p">,</span> <span class="n">eq</span><span class="p">(</span><span class="n">q_lv</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-python notranslate" id="mk-basics-eq-print"><div class="highlight"><pre><span></span><span class="n">pprint</span><span class="p">(</span><span class="n">mk_res</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
</pre></div>
</div>
<p>Since miniKanren’s <code class="docutils literal notranslate"><span class="pre">run</span></code> always returns a stream of results, we obtain
a tuple containing the reified value of <code class="docutils literal notranslate"><span class="pre">q_lv</span></code> under the one
possible state for which our stated goal successfully evaluates.</p>
<p>The other basic primitives represent conjunction and disjunction of miniKanren
goals: <code class="docutils literal notranslate"><span class="pre">lall</span></code> and <code class="docutils literal notranslate"><span class="pre">lany</span></code>, respectively.</p>
<div class="highlight-python notranslate" id="mk-basics-lall"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">kanren</span> <span class="kn">import</span> <span class="n">lall</span><span class="p">,</span> <span class="n">lany</span>

<span class="n">mk_res</span> <span class="o">=</span> <span class="n">run</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">q_lv</span><span class="p">,</span> <span class="n">lall</span><span class="p">(</span><span class="n">eq</span><span class="p">(</span><span class="n">q_lv</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">eq</span><span class="p">(</span><span class="n">q_lv</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>
</pre></div>
</div>
<div class="highlight-python notranslate" id="mk-basics-lall-print"><div class="highlight"><pre><span></span><span class="n">pprint</span><span class="p">(</span><span class="n">mk_res</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="p">()</span>
</pre></div>
</div>
<p>In Listing <a class="reference internal" href="#mk-basics-lall">mk-basics-lall</a>, we used <code class="docutils literal notranslate"><span class="pre">lall</span></code> to obtain the conjunction of two unification goals.
Since we requested that the same logic variable be unified
with both <code class="docutils literal notranslate"><span class="pre">1</span></code> and <code class="docutils literal notranslate"><span class="pre">2</span></code> simultaneously (i.e. in the same
state), which isn’t possible, we got back an empty stream of results–indicating failure.</p>
<p>Goal disjunction, <code class="docutils literal notranslate"><span class="pre">lany</span></code>, will split a state stream across goals,
producing new distinct states for each.</p>
<div class="highlight-python notranslate" id="mk-basics-lany"><div class="highlight"><pre><span></span><span class="n">mk_res</span> <span class="o">=</span> <span class="n">run</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">q_lv</span><span class="p">,</span> <span class="n">lany</span><span class="p">(</span><span class="n">eq</span><span class="p">(</span><span class="n">q_lv</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">eq</span><span class="p">(</span><span class="n">q_lv</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>
</pre></div>
</div>
<div class="highlight-python notranslate" id="mk-basics-lany-print"><div class="highlight"><pre><span></span><span class="n">pprint</span><span class="p">(</span><span class="n">mk_res</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>The goal disjunction results in Listing <a class="reference internal" href="#mk-basics-lany-print">mk-basics-lany-print</a> show that the logic variable
<code class="docutils literal notranslate"><span class="pre">q_lv</span></code> can be unified with either <code class="docutils literal notranslate"><span class="pre">1</span></code> <strong>or</strong> <code class="docutils literal notranslate"><span class="pre">2</span></code> under the
two unification goals.</p>
<p>A common pattern of disjunction and conjunction is called <code class="docutils literal notranslate"><span class="pre">conde</span></code>, and
it mirrors the Lisp function <code class="docutils literal notranslate"><span class="pre">cond</span></code>, which is effectively a type of
compound <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">...</span> <span class="pre">elif</span> <span class="pre">...</span> <span class="pre">elif</span> <span class="pre">...</span></code>.  Specifically,
<code class="docutils literal notranslate"><span class="pre">conde([x_1,</span> <span class="pre">...],</span> <span class="pre">...,</span> <span class="pre">[y_1,</span> <span class="pre">...])</span></code> is the same as
<code class="docutils literal notranslate"><span class="pre">lany(lall(x_1,</span> <span class="pre">...),</span> <span class="pre">...,</span> <span class="pre">lall(y_1,</span> <span class="pre">...))</span></code>–i.e. a disjunction of goal conjunctions.</p>
<div class="highlight-python notranslate" id="mk-basics-conde"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">kanren</span> <span class="kn">import</span> <span class="n">conde</span>

<span class="n">r_lv</span> <span class="o">=</span> <span class="n">var</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>

<span class="n">mk_res</span> <span class="o">=</span> <span class="n">run</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="n">q_lv</span><span class="p">,</span> <span class="n">r_lv</span><span class="p">],</span>
             <span class="n">conde</span><span class="p">(</span>
                 <span class="p">[</span><span class="n">eq</span><span class="p">(</span><span class="n">q_lv</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">eq</span><span class="p">(</span><span class="n">r_lv</span><span class="p">,</span> <span class="mi">10</span><span class="p">)],</span>
                 <span class="p">[</span><span class="n">eq</span><span class="p">(</span><span class="n">q_lv</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">eq</span><span class="p">(</span><span class="n">r_lv</span><span class="p">,</span> <span class="mi">20</span><span class="p">)],</span>
             <span class="p">))</span>
</pre></div>
</div>
<div class="highlight-python notranslate" id="mk-basics-conde-print"><div class="highlight"><pre><span></span><span class="n">pprint</span><span class="p">(</span><span class="n">mk_res</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">20</span><span class="p">])</span>
</pre></div>
</div>
<p>In Listing <a class="reference internal" href="#mk-basics-conde">mk-basics-conde</a>, we introduced another logic
variable, <code class="docutils literal notranslate"><span class="pre">r_lv</span></code>, and requested the reified values of a list
containing both logic variables.  The output resembles the idea that
if <code class="docutils literal notranslate"><span class="pre">q_lv</span></code> is “equal” to <code class="docutils literal notranslate"><span class="pre">1</span></code>, then <code class="docutils literal notranslate"><span class="pre">r_lv</span></code> is “equal”
to <code class="docutils literal notranslate"><span class="pre">10</span></code>, etc.  Unlike normal conditionals, each clause/branch isn’t
exclusive, instead each is realized when the goals in a branch can be successful.</p>
<p>Listing <a class="reference internal" href="#mk-basics-conde-exclusive">mk-basics-conde-exclusive</a>, demonstrates when <code class="docutils literal notranslate"><span class="pre">conde</span></code> can behave more
like a traditional conditional statement.</p>
<div class="highlight-python notranslate" id="mk-basics-conde-exclusive"><div class="highlight"><pre><span></span><span class="n">mk_res</span> <span class="o">=</span> <span class="n">run</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="n">q_lv</span><span class="p">,</span> <span class="n">r_lv</span><span class="p">],</span>
             <span class="n">lall</span><span class="p">(</span><span class="n">eq</span><span class="p">(</span><span class="n">q_lv</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                  <span class="n">conde</span><span class="p">(</span>
                      <span class="p">[</span><span class="n">eq</span><span class="p">(</span><span class="n">q_lv</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">eq</span><span class="p">(</span><span class="n">r_lv</span><span class="p">,</span> <span class="mi">10</span><span class="p">)],</span>
                      <span class="p">[</span><span class="n">eq</span><span class="p">(</span><span class="n">q_lv</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">eq</span><span class="p">(</span><span class="n">r_lv</span><span class="p">,</span> <span class="mi">20</span><span class="p">)],</span>
                  <span class="p">)))</span>
</pre></div>
</div>
<div class="highlight-python notranslate" id="mk-basics-conde-exclusive-print"><div class="highlight"><pre><span></span><span class="n">pprint</span><span class="p">(</span><span class="n">mk_res</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">],)</span>
</pre></div>
</div>
</div>
<div class="section" id="a-better-implementation">
<h3>5.2 A Better Implementation<a class="headerlink" href="#a-better-implementation" title="Permalink to this headline">¶</a></h3>
<p>Since miniKanren uses unification and reification, we can apply its basic goals
to TensorFlow graphs, as we did earlier, and reproduce the entire implementation
in a much more concise manner.</p>
<div class="highlight-python notranslate" id="mk-distribute"><div class="highlight"><pre><span></span><span class="n">mk_res</span> <span class="o">=</span> <span class="n">run</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">output_pat</span><span class="p">,</span>
             <span class="n">eq</span><span class="p">(</span><span class="n">matmul_pat</span><span class="p">,</span> <span class="n">z_sexp</span><span class="p">),</span>
             <span class="n">eq</span><span class="p">(</span><span class="n">add_pat</span><span class="p">,</span> <span class="n">B_lv</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-python notranslate" id="mk-distribute-print"><div class="highlight"><pre><span></span><span class="n">tf_dprint</span><span class="p">(</span><span class="n">mk_res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">eval_obj</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Tensor</span><span class="p">(</span><span class="n">Add</span><span class="p">):</span><span class="mi">0</span><span class="p">,</span>      <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="s2">&quot;Add_2:0&quot;</span>
<span class="o">|</span>  <span class="n">Op</span><span class="p">(</span><span class="n">Add</span><span class="p">)</span>  <span class="s2">&quot;Add_2&quot;</span>
<span class="o">|</span>  <span class="o">|</span>  <span class="n">Tensor</span><span class="p">(</span><span class="n">MatMul</span><span class="p">):</span><span class="mi">0</span><span class="p">,</span>     <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="s2">&quot;MatMul_3:0&quot;</span>
<span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>  <span class="n">Op</span><span class="p">(</span><span class="n">MatMul</span><span class="p">)</span> <span class="s2">&quot;MatMul_3&quot;</span>
<span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>  <span class="n">Tensor</span><span class="p">(</span><span class="n">Placeholder</span><span class="p">):</span><span class="mi">0</span><span class="p">,</span>  <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>      <span class="s2">&quot;A:0&quot;</span>
<span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>  <span class="n">Tensor</span><span class="p">(</span><span class="n">Placeholder</span><span class="p">):</span><span class="mi">0</span><span class="p">,</span>  <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="s2">&quot;x:0&quot;</span>
<span class="o">|</span>  <span class="o">|</span>  <span class="n">Tensor</span><span class="p">(</span><span class="n">MatMul</span><span class="p">):</span><span class="mi">0</span><span class="p">,</span>     <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="s2">&quot;MatMul_4:0&quot;</span>
<span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>  <span class="n">Op</span><span class="p">(</span><span class="n">MatMul</span><span class="p">)</span> <span class="s2">&quot;MatMul_4&quot;</span>
<span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>  <span class="n">Tensor</span><span class="p">(</span><span class="n">Placeholder</span><span class="p">):</span><span class="mi">0</span><span class="p">,</span>  <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>      <span class="s2">&quot;A:0&quot;</span>
<span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>  <span class="n">Tensor</span><span class="p">(</span><span class="n">Placeholder</span><span class="p">):</span><span class="mi">0</span><span class="p">,</span>  <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="s2">&quot;y:0&quot;</span>
</pre></div>
</div>
<p>We didn’t need to use the goal conjunction operator <code class="docutils literal notranslate"><span class="pre">lall</span></code> explicitly
in Listing <a class="reference internal" href="#mk-distribute">mk-distribute</a>, because all remaining goal arguments
to <code class="docutils literal notranslate"><span class="pre">run</span></code> are automatically applied in conjunction.</p>
<p>When combinations of miniKanren goals comprise logical units, we can wrap their
construction in a functions which we call <strong>goal constructors</strong>.</p>
</div>
</div>
</div>


    </div>
</div>
<div class="ui vertical footer segment">
    <div class="ui center aligned container">
        <a href="https://github.com/pymc-devs/symbolic-pymc"><i class="github icon large"></i></a>
        <a href="https://twitter.com/pymc_devs"><i class="twitter icon large"></i></a>
        <a href="https://discourse.pymc.io/"><i class="discourse icon large"></i></a>
    </div>
    <div class="ui center aligned container">
        <p>
            &copy; Copyright 2019, PyMC developers.
        </p>
        <p>
            Created using <a href="https://sphinx-doc.org/">Sphinx</a> 2.2.0.<br />
        </p>
    </div>
</div>
  </body>
</html>